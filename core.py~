#!/usr/bin/env python3
"""
Guitar Tab Generator - Core Implementation
==========================================

Core functionality for converting structured JSON guitar tab specifications
into properly aligned ASCII tablature. This module handles data validation,
tab generation, and error reporting optimized for LLM interaction.

Key Design Decisions:
- Compact notation for techniques (3h5, 12p10) to minimize character usage
- Structured error messages with measure/beat context for LLM correction
- Flexible template system that can accommodate multi-digit frets
- Attempt tracking to prevent infinite LLM regeneration loops
"""

import sys
import json
import logging
from typing import Dict, List, Any, Tuple, Optional
from pydantic import BaseModel, Field, validator

# Configure logging to stderr only (stdout reserved for MCP protocol)
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stderr
)
logger = logging.getLogger(__name__)

# ============================================================================
# Data Models
# ============================================================================

class TabRequest(BaseModel):
    """
    Complete guitar tab specification for processing.
    
    The attempt field enables LLM regeneration tracking - if an LLM gets
    validation errors, it can increment this field and try again, but
    we limit attempts to prevent infinite loops.
    """
    title: str
    description: str = ""
    timeSignature: str = Field(default="4/4", pattern=r"^(4/4|3/4|6/8)$")
    tempo: int = Field(default=120, ge=40, le=300)
    attempt: int = Field(default=1, ge=1, le=10)
    measures: List[Dict[str, Any]]

class TabResponse(BaseModel):
    """
    Response container for both successful tab generation and error reporting.
    
    Warnings are non-fatal issues (like multi-digit frets requiring more space)
    that the LLM should be aware of but don't prevent tab generation.
    """
    success: bool
    content: str = ""
    error: Optional[Dict[str, Any]] = None
    warnings: List[Dict[str, Any]] = []

# ============================================================================
# Validation Pipeline
# ============================================================================

def validate_tab_data(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Multi-stage validation pipeline for guitar tab data.
    
    This uses a fail-fast approach - we stop at the first error type
    to avoid overwhelming the LLM with multiple error categories.
    The staged approach also helps LLMs understand which aspect
    of their JSON needs fixing.
    
    Args:
        data: Raw tab specification dictionary
        
    Returns:
        Error dictionary if validation fails, or {"isError": False} if valid
    """
    logger.debug(f"Starting validation for attempt {data.get('attempt', 1)}")
    
    # Stage 1: Schema and structure validation
    schema_result = validate_schema(data)
    if schema_result["isError"]:
        logger.warning(f"Schema validation failed: {schema_result['message']}")
        return schema_result
    
    # Stage 2: Time signature and beat timing validation  
    timing_result = validate_timing(data)
    if timing_result["isError"]:
        logger.warning(f"Timing validation failed: {timing_result['message']}")
        return timing_result
    
    # Stage 3: Event conflict detection and technique validation
    conflict_result = validate_conflicts(data)
    if conflict_result["isError"]:
        logger.warning(f"Conflict validation failed: {conflict_result['message']}")
        return conflict_result
    
    logger.info("All validation stages passed")
    return {"isError": False}

def validate_schema(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Validate required fields, data types, and basic structure.
    
    We check the most critical fields first (title, measures) since
    these are most likely to be missing in malformed LLM output.
    """
    required_fields = ["title", "timeSignature", "measures"]
    
    for field in required_fields:
        if field not in data:
            return {
                "isError": True,
                "errorType": "validation_error",
                "message": f"Missing required field: {field}",
                "suggestion": f"Add '{field}' property to root object"
            }
    
    # Validate measures array structure
    if not isinstance(data["measures"], list) or len(data["measures"]) == 0:
        return {
            "isError": True,
            "errorType": "validation_error", 
            "message": "Measures array is empty or invalid",
            "suggestion": "Provide at least one measure with events array"
        }
    
    # Validate each measure has events array
    for measure_idx, measure in enumerate(data["measures"], 1):
        if not isinstance(measure, dict) or "events" not in measure:
            return {
                "isError": True,
                "errorType": "validation_error",
                "measure": measure_idx,
                "message": f"Measure {measure_idx} missing events array",
                "suggestion": "Each measure must have an 'events' array (can be empty)"
            }
        
        if not isinstance(measure["events"], list):
            return {
                "isError": True,
                "errorType": "validation_error",
                "measure": measure_idx,
                "message": f"Measure {measure_idx} events is not an array",
                "suggestion": "Events must be an array of event objects"
            }
    
    return {"isError": False}

def validate_timing(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Validate beat timing values against time signature constraints.
    
    Different time signatures have different valid beat subdivisions.
    We're strict about this because incorrect timing makes tabs unplayable.
    The beat validation is the most common error source from LLMs.
    """
    time_sig = data.get("timeSignature", "4/4")
    
    # Define valid beat positions for each time signature
    if time_sig == "4/4":
        valid_beats = [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]
    elif time_sig == "3/4":
        valid_beats = [1.0, 1.5, 2.0, 2.5, 3.0, 3.5]
    elif time_sig == "6/8":
        valid_beats = [1.0, 1.33, 1.67, 2.0, 2.33, 2.67]  # Compound time
    else:
        return {
            "isError": True,
            "errorType": "validation_error",
            "message": f"Unsupported time signature: {time_sig}",
            "suggestion": "Use supported time signatures: 4/4, 3/4, or 6/8"
        }
    
    # Check every event's beat timing
    for measure_idx, measure in enumerate(data["measures"], 1):
        for event_idx, event in enumerate(measure.get("events", []), 1):
            # Extract beat from various event types (some use 'beat', others 'startBeat')
            beat = event.get("beat") or event.get("startBeat")
            
            if beat is None:
                return {
                    "isError": True,
                    "errorType": "validation_error",
                    "measure": measure_idx,
                    "message": f"Event {event_idx} missing beat timing",
                    "suggestion": "Add 'beat' or 'startBeat' field to event"
                }
            
            if beat not in valid_beats:
                return {
                    "isError": True,
                    "errorType": "validation_error",
                    "measure": measure_idx,
                    "beat": beat,
                    "message": f"Beat {beat} invalid for {time_sig} time signature",
                    "suggestion": f"Use valid beat values: {', '.join(map(str, valid_beats))}"
                }
    
    return {"isError": False}

def validate_conflicts(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Check for conflicting events and validate technique-specific rules.
    
    This catches the subtle errors that make tabs unplayable:
    - Multiple notes on same string at same time
    - Invalid technique parameters (hammer-on going down, etc.)
    - String/fret range violations
    
    For chord events, we allow multiple strings at the same beat since
    that's the whole point of chords.
    """
    for measure_idx, measure in enumerate(data["measures"], 1):
        events_by_position = {}
        
        for event in measure.get("events", []):
            event_type = event.get("type")
            
            # Validate event has required type field
            if not event_type:
                return {
                    "isError": True,
                    "errorType": "validation_error",
                    "measure": measure_idx,
                    "message": "Event missing 'type' field",
                    "suggestion": "Add 'type' field with value like 'note', 'hammerOn', 'chord', etc."
                }
            
            # Handle chord events specially - they can have multiple strings at same beat
            if event_type == "chord":
                beat = event.get("beat")
                if not beat:
                    return {
                        "isError": True,
                        "errorType": "validation_error",
                        "measure": measure_idx,
                        "message": "Chord event missing 'beat' field",
                        "suggestion": "Add 'beat' field to chord event"
                    }
                
                # Validate chord has frets array
                frets = event.get("frets", [])
                if not frets:
                    return {
                        "isError": True,
                        "errorType": "validation_error",
                        "measure": measure_idx,
                        "beat": beat,
                        "message": "Chord event missing 'frets' array",
                        "suggestion": "Add 'frets' array with string/fret objects"
                    }
                
                # Check for duplicate strings within the chord
                chord_strings = set()
                for fret_info in frets:
                    string_num = fret_info.get("string")
                    if string_num in chord_strings:
                        return {
                            "isError": True,
                            "errorType": "conflict_error",
                            "measure": measure_idx,
                            "beat": beat,
                            "message": f"Chord has duplicate entries for string {string_num}",
                            "suggestion": "Each string can only appear once per chord"
                        }
                    chord_strings.add(string_num)
                
                continue  # Skip position conflict checking for chords
            
            # For non-chord events, check string/beat conflicts
            string_num = event.get("string")
            beat = event.get("beat") or event.get("startBeat")
            
            if not string_num or not beat:
                continue  # These will be caught by other validation
                
            position_key = f"{string_num}_{beat}"
            
            if position_key in events_by_position:
                return {
                    "isError": True,
                    "errorType": "conflict_error",
                    "measure": measure_idx,
                    "beat": beat,
                    "message": f"Multiple events on string {string_num} at beat {beat}",
                    "suggestion": "Move one event to different beat or different string"
                }
            
            events_by_position[position_key] = event
            
            # Validate technique-specific rules
            technique_error = validate_technique_rules(event, measure_idx, beat)
            if technique_error["isError"]:
                return technique_error
    
    return {"isError": False}

def validate_technique_rules(event: Dict[str, Any], measure_idx: int, beat: float) -> Dict[str, Any]:
    """
    Validate technique-specific rules that ensure playability.
    
    Each guitar technique has physical constraints:
    - Hammer-ons must go to higher fret (you can't hammer down)
    - Pull-offs must go to lower fret  
    - String numbers must be 1-6
    - Fret numbers must be 0-24 (practical guitar range)
    """
    event_type = event.get("type")
    
    # Validate string range for all events with string field
    string_num = event.get("string")
    if string_num is not None and (string_num < 1 or string_num > 6):
        return {
            "isError": True,
            "errorType": "validation_error",
            "measure": measure_idx,
            "beat": beat,
            "message": f"Invalid string number: {string_num}",
            "suggestion": "String numbers must be 1-6 (1=high e, 6=low E)"
        }
    
    # Validate fret ranges
    for fret_field in ["fret", "fromFret", "toFret"]:
        fret = event.get(fret_field)
        if fret is not None and (fret < 0 or fret > 24):
            return {
                "isError": True,
                "errorType": "validation_error",
                "measure": measure_idx,
                "beat": beat,
                "message": f"Invalid fret number: {fret}",
                "suggestion": "Fret numbers must be 0-24"
            }
    
    # Technique-specific validations
    if event_type == "hammerOn":
        from_fret = event.get("fromFret")
        to_fret = event.get("toFret")
        if from_fret is not None and to_fret is not None and from_fret >= to_fret:
            return {
                "isError": True,
                "errorType": "validation_error",
                "measure": measure_idx,
                "beat": beat,
                "message": f"Hammer-on fromFret ({from_fret}) must be lower than toFret ({to_fret})",
                "suggestion": "Hammer-ons go to higher frets - check fromFret and toFret values"
            }
    
    elif event_type == "pullOff":
        from_fret = event.get("fromFret")
        to_fret = event.get("toFret")
        if from_fret is not None and to_fret is not None and from_fret <= to_fret:
            return {
                "isError": True,
                "errorType": "validation_error",
                "measure": measure_idx,
                "beat": beat,
                "message": f"Pull-off fromFret ({from_fret}) must be higher than toFret ({to_fret})",
                "suggestion": "Pull-offs go to lower frets - check fromFret and toFret values"
            }
    
    return {"isError": False}

# ============================================================================
# Tab Generation Engine
# ============================================================================

def generate_tab_output(data: Dict[str, Any]) -> Tuple[str, List[Dict[str, Any]]]:
    """
    Generate formatted ASCII tablature from validated data.
    
    Returns both the tab string and any warnings about formatting issues.
    The warning system lets LLMs know about potential display problems
    without failing the entire generation.
    
    Key design choice: We process measures in groups of 4 for readability.
    This is a standard convention in printed music and keeps line lengths
    manageable for both human reading and LLM processing.
    """
    logger.info(f"Generating tab for '{data.get('title', 'Untitled')}'")
    
    measures = data["measures"]
    warnings = []
    output_lines = []
    
    # Generate header information
    title = data.get("title", "Untitled")
    description = data.get("description", "")
    time_sig = data.get("timeSignature", "4/4")
    tempo = data.get("tempo")
    
    output_lines.append(f"# {title}")
    if description:
        output_lines.append(f"*{description}*")
    
    # Add tempo/time signature info
    info_line = f"**Time Signature:** {time_sig}"
    if tempo:
        info_line += f" | **Tempo:** {tempo} BPM"
    output_lines.append(info_line)
    output_lines.append("")
    
    # Process measures in groups of 4 for formatting
    for measure_group_start in range(0, len(measures), 4):
        measure_group = measures[measure_group_start:measure_group_start + 4]
        tab_section, section_warnings = generate_measure_group(measure_group, measure_group_start)
        warnings.extend(section_warnings)
        output_lines.extend(tab_section)
        output_lines.append("")  # Space between groups
    
    logger.info(f"Generated tab with {len(warnings)} warnings")
    return "\n".join(output_lines), warnings

def generate_measure_group(measures: List[Dict[str, Any]], start_index: int) -> Tuple[List[str], List[Dict[str, Any]]]:
    """
    Generate tab section for up to 4 measures.
    
    The template system is designed to be flexible for different content:
    - Standard measures get 18 characters (17 dashes + 1 separator)
    - Multi-digit frets may require expanding this template
    - Beat markers align exactly with note positions
    
    This is where the rubber meets the road for tab alignment - any bugs
    here will result in misaligned output that's unusable.
    """
    warnings = []
    num_measures = len(measures)
    
    # Create beat markers - this depends on time signature
    # For now, assume 4/4 time signature
    beat_line = " 1 & 2 & 3 & 4 &  " * num_measures
    
    # Initialize string lines with template dashes
    # 6 strings (high e to low E), each with dashes and measure separators
    string_lines = []
    for string_idx in range(6):
        line = ""
        for measure_idx in range(num_measures):
            line += "|" + "-" * 17  # 17 dashes per measure
        line += "|"  # Final separator
        string_lines.append(line)
    
    # Place events on appropriate string lines
    for measure_idx, measure in enumerate(measures):
        measure_warnings = place_measure_events(measure, string_lines, measure_idx, start_index + measure_idx + 1)
        warnings.extend(measure_warnings)
    
    # Combine beat markers with string lines
    result = [beat_line]
    result.extend(string_lines)
    
    return result, warnings

def place_measure_events(measure: Dict[str, Any], string_lines: List[str], measure_offset: int, measure_number: int) -> List[Dict[str, Any]]:
    """
    Place all events from one measure onto the tab lines.
    
    This function handles the complex logic of converting abstract
    musical events into precise character positions in the ASCII tab.
    Each event type has different placement rules and character requirements.
    """
    warnings = []
    
    for event in measure.get("events", []):
        event_warnings = place_event_on_tab(event, string_lines, measure_offset, measure_number)
        warnings.extend(event_warnings)
    
    return warnings

def place_event_on_tab(event: Dict[str, Any], string_lines: List[str], measure_offset: int, measure_number: int) -> List[Dict[str, Any]]:
    """
    Place individual event on the appropriate tab line.
    
    This is the core algorithm that converts musical events to ASCII characters.
    Key challenges:
    - Multi-digit frets require multiple character positions
    - Techniques like "10h12" can be 5+ characters long
    - Must maintain precise beat alignment despite variable-width content
    - Need to detect when content won't fit in standard template
    """
    warnings = []
    event_type = event.get("type")
    
    if event_type == "note":
        string_num = event["string"]
        beat = event["beat"]
        fret = str(event["fret"])
        
        char_position = calculate_char_position(beat, measure_offset)
        line_index = string_num - 1  # Convert 1-indexed to 0-indexed
        print(f"DEBUG: Placing fret {fret} at position {char_position} on string {string_num}", file=sys.stderr) 
        string_lines[line_index] = replace_chars_at_position(string_lines[line_index], char_position, fret)
        print(f"DEBUG: Line after: {string_lines[line_index]}", file=sys.stderr)
        
        # Warn about multi-digit frets that may cause alignment issues
        if len(fret) > 1:
            warnings.append({
                "warningType": "formatting_warning",
                "measure": measure_number,
                "beat": beat,
                "message": f"Multi-digit fret ({fret}) may affect template alignment",
                "suggestion": f"Fret {fret} uses {len(fret)} character positions"
            })
    
    elif event_type == "chord":
        beat = event["beat"]
        char_position = calculate_char_position(beat, measure_offset)
        
        max_fret_width = 0
        for fret_info in event["frets"]:
            string_num = fret_info["string"] 
            fret = str(fret_info["fret"])
            line_index = string_num - 1
            
            string_lines[line_index] = replace_chars_at_position(string_lines[line_index], char_position, fret)
            max_fret_width = max(max_fret_width, len(fret))
        
        # Warn about chords with wide fret numbers
        if max_fret_width > 1:
            warnings.append({
                "warningType": "formatting_warning", 
                "measure": measure_number,
                "beat": beat,
                "message": f"Chord with multi-digit frets may affect alignment",
                "suggestion": f"Chord requires {max_fret_width} character positions"
            })
    
    elif event_type in ["hammerOn", "pullOff"]:
        string_num = event["string"]
        beat = event["startBeat"]
        from_fret = str(event["fromFret"])
        to_fret = str(event["toFret"])
        symbol = "h" if event_type == "hammerOn" else "p"
        
        char_position = calculate_char_position(beat, measure_offset)
        line_index = string_num - 1
        
        # Compact format: "3h5" or "10p12"
        technique_str = f"{from_fret}{symbol}{to_fret}"
        string_lines[line_index] = replace_chars_at_position(string_lines[line_index], char_position, technique_str)
        
        # Warn about wide technique notations
        if len(technique_str) > 3:
            warnings.append({
                "warningType": "formatting_warning",
                "measure": measure_number,
                "beat": beat,
                "message": f"Technique notation '{technique_str}' may require template adjustment",
                "suggestion": f"Technique uses {len(technique_str)} character positions"
            })
    
    elif event_type == "slide":
        string_num = event["string"]
        beat = event["startBeat"]
        from_fret = str(event["fromFret"])
        to_fret = str(event["toFret"])
        symbol = "/" if event["direction"] == "up" else "\\"
        
        char_position = calculate_char_position(beat, measure_offset)
        line_index = string_num - 1
        
        # Compact format: "3/5" or "12\8"  
        technique_str = f"{from_fret}{symbol}{to_fret}"
        string_lines[line_index] = replace_chars_at_position(string_lines[line_index], char_position, technique_str)
        
        if len(technique_str) > 3:
            warnings.append({
                "warningType": "formatting_warning",
                "measure": measure_number,
                "beat": beat,
                "message": f"Slide notation '{technique_str}' may require template adjustment",
                "suggestion": f"Slide uses {len(technique_str)} character positions"
            })
    
    elif event_type == "bend":
        string_num = event["string"]
        beat = event["beat"]
        fret = str(event["fret"])
        # symbol = event["symbol"]  # 'b' or 'r'
        # Generate symbol based on bendType
        bend_type = event.get("bendType", "bend")
        symbol = "b" if bend_type == "bend" else "r"
        
        char_position = calculate_char_position(beat, measure_offset)
        line_index = string_num - 1
        
        # Compact format: "3b" or "5r"
        technique_str = f"{fret}{symbol}"
        string_lines[line_index] = replace_chars_at_position(string_lines[line_index], char_position, technique_str)
    
    return warnings

def calculate_char_position(beat: float, measure_offset: int) -> int:
    """
    Calculate exact character position for a given beat within the template.
    
    This is critical for proper alignment - any error here results in
    notes appearing at wrong times. The mapping must exactly match
    the beat marker positions in the header line.
    
    For 4/4 time signature:
    - Each measure uses 18 characters (17 content + 1 separator)
    - Beat positions are: 1.0->1, 1.5->3, 2.0->5, etc.
    - Measure offset shifts the base position by measure_offset * 18
    """
    # Beat to character position mapping for 4/4 time
    beat_map = {
        1.0: 2, 1.5: 4, 2.0: 6, 2.5: 8,
        3.0: 10, 3.5: 12, 4.0: 14, 4.5: 16
    }
    
    base_position = beat_map.get(beat, 1)
    
    # Each measure takes 18 characters in the template
    return base_position + (measure_offset * 18)

def replace_chars_at_position(line: str, position: int, replacement: str) -> str:
    """
    Replace characters in string at specific position, maintaining string length.
    
    This is a critical utility that must preserve the exact character alignment
    of the tab template. We convert to list for efficient character replacement,
    then back to string.
    
    Edge case handling: If replacement is longer than remaining space,
    we truncate rather than extending the line (which would break alignment).
    """
    line_list = list(line)
    
    for i, char in enumerate(replacement):
        target_pos = position + i
        if target_pos < len(line_list):
            line_list[target_pos] = char
        else:
            # Character position beyond line length - this shouldn't happen
            # with proper template sizing, but we handle it gracefully
            logger.warning(f"Character position {target_pos} beyond line length {len(line_list)}")
            break
    
    return "".join(line_list)

# ============================================================================
# Error Handling Utilities
# ============================================================================

def check_attempt_limit(attempt: int) -> Optional[Dict[str, Any]]:
    """
    Check if LLM has exceeded regeneration attempt limit.
    
    This prevents infinite loops when an LLM repeatedly generates
    invalid JSON. After 5 attempts, we assume there's a fundamental
    misunderstanding and provide guidance to start over.
    """
    MAX_ATTEMPTS = 5
    
    if attempt > MAX_ATTEMPTS:
        return {
            "isError": True,
            "errorType": "attempt_limit_error",
            "attempt": attempt,
            "message": f"Maximum regeneration attempts reached ({attempt})",
            "suggestion": "Review input data structure or simplify the tab requirements. Consider starting with a basic single-measure example."
        }
    
    return None
